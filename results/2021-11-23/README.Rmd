---
title: "Description of sequencing data received"
author: "J. Ignacio Lucas LledÃ³"
date: "23/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We received a link to download the data with the warning:

> LUCASJIG_01: the results from lane 2 do not look very good,
> it seems it's an issue with the kit. However, if you do a
> stringent filtering you still can use the data. In any case
> we will resequence as soon as possible.

We also got a list of the total number of reads per sample, including the
mock samples that identify index hopping events. I paste this information
in the file `numReads.txt`, to be checked. I downloaded the data and checked
their md5sum in `data/fastq`.

## Checking sample-index correspondance

On `2021-10-13` I created the file `SampleIndexSeq.tsv`, which was used to
communicate the assignment of samples to combinations of indices. Here I want
to make sure that the reads we got are correctly assigned to samples, because
the fastq file names include sample and index sequence. I note, however, that
the index sequences included in the fastq file name are the reverse-complements
of the index sequences used in the `SampleIndexSeq.tsv`.

```{bash files}
if [ ! -e comparison.txt ]; then
   if [ ! -e fromOriginalAssignment.txt ]; then
      if [ ! -e SampleIndexSeq.tsv ]; then
         cp ../2021-10-13/SampleIndexSeq.tsv ./
      fi
      
      # head SampleIndexSeq.tsv
      # "Sample"        "i7"    "i7seq" "i5"    "i5seq"
      # "BIE002"        "N701"  "TCGCCTTA"      "S502"  "CTCTCTAT"
      # "BRZ001"        "N701"  "TCGCCTTA"      "S503"  "TATCCTCT"
      # "THU001"        "N701"  "TCGCCTTA"      "S505"  "GTAAGGAG"
      # "WAL003"        "N701"  "TCGCCTTA"      "S506"  "ACTGCATA"
      # "LAN005"        "N701"  "TCGCCTTA"      "S507"  "AAGGAGTA"
      # "SUO001"        "N701"  "TCGCCTTA"      "S508"  "CTAAGCCT"
      # ...
      
      gawk '(NR > 1){gsub(/\"/,""); print $1 "\t" $3 "\t" $5}' SampleIndexSeq.tsv | sort -k 1,1 > fromOriginalAssignment.txt
   fi

   if [ ! -e fromFileNames.txt ]; then
      # ls -1 ../../data/fastq | grep 'fastq.gz' | grep '_R1_' | head
      # 175600_12752AAC_GTAGAGGA-CTTAATAG_R1_001.fastq.gz
      # 175601_12765AAC_GCTCATGA-AGCTAGAA_R1_001.fastq.gz
      # 175602_12767AAC_GCTCATGA-TCTTACGC_R1_001.fastq.gz
      # 175603_12769AAC_GCTCATGA-ATAGCCTT_R1_001.fastq.gz
      # 175604_12796AAC_ACTCGCTA-CTAGTCGA_R1_001.fastq.gz
      # 175605_12798AAC_ACTCGCTA-ACTCTAGG_R1_001.fastq.gz
      # 175606_12800AAC_ACTCGCTA-CTTAATAG_R1_001.fastq.gz
      # ...
      
      ls -1 ../../data/fastq | grep 'fastq.gz' | grep '_R1_' | cut -d '_' -f 1 > z1
      ls -1 ../../data/fastq | grep 'fastq.gz' | grep '_R1_' | cut -d '_' -f 3 | \
         cut -d '-' -f 1 | tr ACGT TGCA | rev > z2
      ls -1 ../../data/fastq | grep 'fastq.gz' | grep '_R1_' | cut -d '_' -f 3 | \
         cut -d '-' -f 2 | tr ACGT TGCA | rev > z3
      paste z1 z2 z3 | sort -k 1,1 > fromFileNames.txt
      rm z1 z2 z3
   fi
   
   sdiff fromOriginalAssignment.txt fromFileNames.txt > comparison.txt
   rm fromOriginalAssignment.txt fromFileNames.txt
fi
grep -P "[\|><]" comparison.txt
```

Thus, the only difference between the original assignment of indices to reads and the
one reported is that there are no fastq files for some *HOP* mock samples, which is
expected.

## Number of reads per sample

We have a report of how many reads are there for every sample. But I want to check if
it is correct, and if they are counting single reads or pairs. The reported numbers
of reads per sample are manually saved in the file `numReads.txt`.

```{bash numReads}
if [ ! -e checkNumReads.txt ]; then
   FASTQDIR='../../data/fastq'
   SAMPLE=( $(gawk '(NR > 1){gsub(/\"/,""); print $1}' SampleIndexSeq.tsv | sort) )
   THREADS=48
   for i in $(seq 0 $THREADS $(( ${#SAMPLE[@]} - 1 )) ); do
      for j in $(seq $i $(($i + $THREADS - 1)) ); do
         echo -e ${SAMPLE[$j]} "\t" \
            $(echo $(gunzip -c $FASTQDIR/${SAMPLE[$j]}*_R1_001.fastq.gz 2> /dev/null | wc -l) "/4" | bc) \
            > $(printf "z_%s.txt" ${SAMPLE[$j]}) &
      done
      wait
   done
   cat z_*.txt | sort -k 1,1 > checkNumReads.txt
   sed -i 's/ //g' checkNumReads.txt
   rm z*
fi

if [ ! -e numReads.txt ]; then
   echo "File numReads.txt is missing."
else
   gawk '{print $3 "\t" $4}' numReads.txt | sort -k 1,1 > z1
   NUMDIF=$(sdiff checkNumReads.txt z1 | tee comparison2.txt | grep -P "[\|<>]" | wc -l)
   echo "There are $NUMDIF differences between reported and calculated read counts."
   rm z1
fi
```

## Relationship between number of reads and DNA sample features

There are four data sets I need to combine in one data frame, or two:

1. The number of read pairs per sample.
2. The main features of the DNA samples (concentration, integrity indicators, tissue of origin...).
3. The features of the fish from which DNA was extracted (apparent species, lake of origin, sex, age...).
4. The distribution of samples among the four 96-well plates.

Whe have 280 samples, but 374 pairs of fastq files and 384 rows in the sample sheet
that assigns samples to combinations of indices. This is because there are 104
index combinations not actually used for any sample, but attributed to mock
samples named with the *HOP* prefix. Among those, 10 did not receive any read
assigned to them, and therefore lack fastq files. I want to include the mock
samples in the analysis.

```{r data}
# Starting with the table with all 384 rows:

Features <- read.table(ifelse(file.exists('SampleIndexSeq.tsv'),
                              'SampleIndexSeq.tsv',
                              '../2021-10-13/SampleIndexSeq.tsv'),
                       header = TRUE, row.names = 1)

# Adding plate information:
A  <- read.table('../../data/plate_A.tsv', header = TRUE, as.is = TRUE)
B  <- read.table('../../data/plate_B.tsv', header = TRUE, as.is = TRUE)
C  <- read.table('../../data/plate_C.tsv', header = TRUE, as.is = TRUE)
D  <- read.table('../../data/plate_D.tsv', header = TRUE, as.is = TRUE)
isA <- as.vector(A[! is.na(A)])
isB <- as.vector(B[! is.na(B)])
isC <- as.vector(C[! is.na(C)])
isD <- as.vector(D[! is.na(D)])

Features$plate <- factor(NA, levels = c('A','B','C','D'))
Features[isA, 'plate'] <- 'A'
Features[isB, 'plate'] <- 'B'
Features[isC, 'plate'] <- 'C'
Features[isD, 'plate'] <- 'D'

rm(isA, isB, isC, isC)

Plates <- as.matrix(rbind(cbind(A,B), cbind(C,D)))

# Adding fish information
Fish <- read.table('../../data/Fish_clean.tsv', header = TRUE, sep = '\t')
Fish$Date <- as.Date(Fish$Date, "%d.%m.%Y")
Fish$Date_dissect <- as.Date(Fish$Date_dissect, "%d.%m.%Y")
Fish$LongKept <- Fish$Date_dissect - Fish$Date  # Number of days between catchment and dissection
Fish$Fish_code <- as.character(Fish$Fish_code)  # This is not a factor
row.names(Fish) <- Fish$Fish_code

Features$lake      <- Fish[row.names(Features), 'Lake']
Features$region    <- Fish[row.names(Features), 'Region']
Features$catchment <- Fish[row.names(Features), 'Catchment']
Features$date      <- Fish[row.names(Features), 'Date']
Features$furka     <- Fish[row.names(Features), 'Furka_length']
Features$weight    <- Fish[row.names(Features), 'Weight_g']
Features$sex       <- Fish[row.names(Features), 'Sex']
Features$age       <- Fish[row.names(Features), 'Age']
Features$condition <- Fish[row.names(Features), 'Condition']
Features$sciName   <- Fish[row.names(Features), 'Sci_name_CONSENSUS_ID']

# Adding DNA extraction features:
dna <- read.table('../../data/dna_quality.csv', header = TRUE,
                  colClasses = c('character','numeric','factor','factor',
                                 'factor','factor'),
                  row.names = 1)
dna$Electroforesis <- factor(dna$Electroforesis,
                             levels = c('MuyDegradado','Degradado','Utilizable',
                                        'UtilizableBanda','Bien'))

Features$Concentration  <- dna[row.names(Features), 'Concentration']
Features$Electroforesis <- dna[row.names(Features), 'Electroforesis']
Features$Tissue         <- dna[row.names(Features), 'Tissue']
Features$Extraction     <- dna[row.names(Features), 'Extraction']
Features$Evaporated     <- dna[row.names(Features), 'Evaporated']

rm(dna)

# Adding number of reads
numReads <- read.table('checkNumReads.txt', col.names=c('sample','reads'), row.names=1)
Features$numReads <- numReads[row.names(Features), 'reads']

# Adding a filter for real samples
Features$isReal <- ! startsWith(row.names(Features), 'HOP')

# Saving this table, because it may be used in future folders.
write.table(Features, file = 'Features.csv', quote = FALSE, sep = "\t")
save(Features, file = 'Features.RData')

boxplot(numReads ~ lake, data = Features, xlab = 'Lake', ylab = 'Number of reads per sample')
```

## SessionInfo

```{r sessioninfo}
sessionInfo()
```