---
title: "Description of sequencing data received"
author: "J. Ignacio Lucas LledÃ³"
date: "23/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We received a link to download the data with the warning:

> LUCASJIG_01: the results from lane 2 do not look very good,
> it seems it's an issue with the kit. However, if you do a
> stringent filtering you still can use the data. In any case
> we will resequence as soon as possible.

We also got a list of the total number of reads per sample, including the
mock samples that identify index hopping events. I paste this information
in the file `numReads.txt`, to be checked. I downloaded the data and checked
their md5sum in `data/fastq`.

## Checking sample-index correspondance

On `2021-10-13` I created the file `SampleIndexSeq.tsv`, which was used to
communicate the assignment of samples to combinations of indices. Here I want
to make sure that the reads we got are correctly assigned to samples, because
the fastq file names include sample and index sequence. I note, however, that
the index sequences included in the fastq file name are the reverse-complements
of the index sequences used in the `SampleIndexSeq.tsv`.

```{bash files}
if [ ! -e comparison.txt ]; then
   if [ ! -e fromOriginalAssignment.txt ]; then
      if [ ! -e SampleIndexSeq.tsv ]; then
         cp ../2021-10-13/SampleIndexSeq.tsv ./
      fi
      
      # head SampleIndexSeq.tsv
      # "Sample"        "i7"    "i7seq" "i5"    "i5seq"
      # "BIE002"        "N701"  "TCGCCTTA"      "S502"  "CTCTCTAT"
      # "BRZ001"        "N701"  "TCGCCTTA"      "S503"  "TATCCTCT"
      # "THU001"        "N701"  "TCGCCTTA"      "S505"  "GTAAGGAG"
      # "WAL003"        "N701"  "TCGCCTTA"      "S506"  "ACTGCATA"
      # "LAN005"        "N701"  "TCGCCTTA"      "S507"  "AAGGAGTA"
      # "SUO001"        "N701"  "TCGCCTTA"      "S508"  "CTAAGCCT"
      # ...
      
      gawk '(NR > 1){gsub(/\"/,""); print $1 "\t" $3 "\t" $5}' SampleIndexSeq.tsv | sort -k 1,1 > fromOriginalAssignment.txt
   fi

   if [ ! -e fromFileNames.txt ]; then
      # ls -1 ../../data/fastq | grep 'fastq.gz' | grep '_R1_' | head
      # 175600_12752AAC_GTAGAGGA-CTTAATAG_R1_001.fastq.gz
      # 175601_12765AAC_GCTCATGA-AGCTAGAA_R1_001.fastq.gz
      # 175602_12767AAC_GCTCATGA-TCTTACGC_R1_001.fastq.gz
      # 175603_12769AAC_GCTCATGA-ATAGCCTT_R1_001.fastq.gz
      # 175604_12796AAC_ACTCGCTA-CTAGTCGA_R1_001.fastq.gz
      # 175605_12798AAC_ACTCGCTA-ACTCTAGG_R1_001.fastq.gz
      # 175606_12800AAC_ACTCGCTA-CTTAATAG_R1_001.fastq.gz
      # ...
      
      ls -1 ../../data/fastq | grep 'fastq.gz' | grep '_R1_' | cut -d '_' -f 1 > z1
      ls -1 ../../data/fastq | grep 'fastq.gz' | grep '_R1_' | cut -d '_' -f 3 | \
         cut -d '-' -f 1 | tr ACGT TGCA | rev > z2
      ls -1 ../../data/fastq | grep 'fastq.gz' | grep '_R1_' | cut -d '_' -f 3 | \
         cut -d '-' -f 2 | tr ACGT TGCA | rev > z3
      paste z1 z2 z3 | sort -k 1,1 > fromFileNames.txt
      rm z1 z2 z3
   fi
   
   sdiff fromOriginalAssignment.txt fromFileNames.txt > comparison.txt
   rm fromOriginalAssignment.txt fromFileNames.txt
fi
grep -P "[\|><]" comparison.txt
```

Thus, the only difference between the original assignment of indices to reads and the
one reported is that there are no fastq files for some *HOP* mock samples, which is
expected.

## Number of reads per sample

We have a report of how many reads are there for every sample. But I want to check if
it is correct, and if they are counting single reads or pairs. The reported numbers
of reads per sample are manually saved in the file `numReads.txt`.

```{bash numReads}
if [ ! -e checkNumReads.txt ]; then
   FASTQDIR='../../data/fastq'
   SAMPLE=( $(gawk '(NR > 1){gsub(/\"/,""); print $1}' SampleIndexSeq.tsv | sort) )
   THREADS=48
   for i in $(seq 0 $THREADS $(( ${#SAMPLE[@]} - 1 )) ); do
      for j in $(seq $i $(($i + $THREADS - 1)) ); do
         echo -e ${SAMPLE[$j]} "\t" \
            $(echo $(gunzip -c $FASTQDIR/${SAMPLE[$j]}*_R1_001.fastq.gz 2> /dev/null | wc -l) "/4" | bc) \
            > $(printf "z_%s.txt" ${SAMPLE[$j]}) &
      done
      wait
   done
   cat z_*.txt | sort -k 1,1 > checkNumReads.txt
   sed -i 's/ //g' checkNumReads.txt
   rm z*
fi

if [ ! -e numReads.txt ]; then
   echo "File numReads.txt is missing."
else
   gawk '{print $3 "\t" $4}' numReads.txt | sort -k 1,1 > z1
   NUMDIF=$(sdiff checkNumReads.txt z1 | tee comparison2.txt | grep -P "[\|<>]" | wc -l)
   echo "There are $NUMDIF differences between reported and calculated read counts."
   rm z1
fi
```

## Relationship between number of reads and DNA sample features

There are four data sets I need to combine in one data frame, or two:

1. The number of read pairs per sample.
2. The main features of the DNA samples (concentration, integrity indicators, tissue of origin...).
3. The features of the fish from which DNA was extracted (apparent species, lake of origin, sex, age...).
4. The distribution of samples among the four 96-well plates.

Whe have 280 samples, but 374 pairs of fastq files and 384 rows in the sample sheet
that assigns samples to combinations of indices. This is because there are 104
index combinations not actually used for any sample, but attributed to mock
samples named with the *HOP* prefix. Among those, 10 did not receive any read
assigned to them, and therefore lack fastq files. I want to include the mock
samples in the analysis.

```{r data}
# Starting with the table with all 384 rows:

Features <- read.table(ifelse(file.exists('SampleIndexSeq.tsv'),
                              'SampleIndexSeq.tsv',
                              '../2021-10-13/SampleIndexSeq.tsv'),
                       header = TRUE, row.names = 1)

# Adding plate information:
# Plate A has i5 S502-S511 and i7 N701-N715
# Plate B has i5 S502-S511 and i7 N716-N729
# Plate C has i5 S513-S522 and i7 N701-N715
# Plate D has i5 S513-S522 and i7 N716-N729

Features$plate <- factor(NA, levels = c('A','B','C','D'))
Features[Features$i5 %in% paste0('S', 502:511) &
            Features$i7 %in% paste0('N', 701:715), 'plate'] <- 'A'
Features[Features$i5 %in% paste0('S', 502:511) &
            Features$i7 %in% paste0('N', 716:729), 'plate'] <- 'B'
Features[Features$i5 %in% paste0('S', 513:522) &
            Features$i7 %in% paste0('N', 701:715), 'plate'] <- 'C'
Features[Features$i5 %in% paste0('S', 513:522) &
            Features$i7 %in% paste0('N', 716:729), 'plate'] <- 'D'

# Adding fish information
Fish <- read.table('../../data/Fish_clean.tsv', header = TRUE, sep = '\t')
Fish$Date <- as.Date(Fish$Date, "%d.%m.%Y")
Fish$Date_dissect <- as.Date(Fish$Date_dissect, "%d.%m.%Y")
Fish$LongKept <- Fish$Date_dissect - Fish$Date  # Number of days between catchment and dissection
Fish$Fish_code <- as.character(Fish$Fish_code)  # This is not a factor
row.names(Fish) <- Fish$Fish_code

Features$lake      <- Fish[row.names(Features), 'Lake']
Features$region    <- Fish[row.names(Features), 'Region']
Features$catchment <- Fish[row.names(Features), 'Catchment']
Features$date      <- Fish[row.names(Features), 'Date']
Features$furka     <- Fish[row.names(Features), 'Furka_length']
Features$weight    <- Fish[row.names(Features), 'Weight_g']
Features$sex       <- Fish[row.names(Features), 'Sex']
Features$age       <- Fish[row.names(Features), 'Age']
Features$condition <- Fish[row.names(Features), 'Condition']
Features$sciName   <- Fish[row.names(Features), 'Sci_name_CONSENSUS_ID']

# Adding DNA extraction features:
dna <- read.table('../../data/dna_quality.csv', header = TRUE,
                  colClasses = c('character','numeric','factor','factor',
                                 'factor','factor'),
                  row.names = 1)
dna$Electroforesis <- factor(dna$Electroforesis,
                             levels = c('MuyDegradado','Degradado','Utilizable',
                                        'UtilizableBanda','Bien'))

Features$Concentration  <- dna[row.names(Features), 'Concentration']
Features$Electroforesis <- dna[row.names(Features), 'Electroforesis']
Features$Tissue         <- dna[row.names(Features), 'Tissue']
Features$Extraction     <- dna[row.names(Features), 'Extraction']
Features$Evaporated     <- dna[row.names(Features), 'Evaporated']

rm(dna)

# Adding number of reads
numReads <- read.table('checkNumReads.txt', col.names=c('sample','reads'), row.names=1)
Features$numReads <- numReads[row.names(Features), 'reads']

# Adding a filter for real samples
Features$isReal <- ! startsWith(row.names(Features), 'HOP')

# Saving this table, because it may be used in future folders.
write.table(Features, file = 'Features.csv', quote = FALSE, sep = "\t")
save(Features, file = 'Features.RData')
```

I suppose, the right thing to do is a thoughtful linear model. But, it's so
easy to just make some plots!

```{r somePlots}
library(ggplot2)
ggplot(data = Features, mapping = aes(x = lake, y = numReads)) +
   geom_boxplot(notch = FALSE)

ggplot(data = Features, mapping = aes(x = Electroforesis, y = numReads)) +
   geom_boxplot(notch = FALSE)

ggplot(data = Features, mapping = aes(x = Concentration, y = numReads, color = Electroforesis)) +
   geom_point() + geom_smooth(method = 'lm')
```

The question is what determines the final number of reads that get sequenced in a sample.
DNA concentration after extraction is an indication of how successful the extraction was,
and it is reasonable to suspect that sequencing success is limited by DNA the amount of
DNA. However, we have taken a lot of care to balance the amount of DNA among samples,
precisely to remove the variation due to differences in DNA concentration after extraction.
Only the samples with the lowest initial concentrations, presumably those labeled
*MuyDegradado*, could not be added to the pool in a proportional amount. We already
expected those to have a lower yield.

The graphs confirm our overall success at balancing the amount of DNA among samples, and
point at the quality of the DNA as the main cause of differences in the number of reads.

## Distribution of the number of reads in the PCR plates
The positions of samples in the four 96-well plates where the indices were attached
could reveal biases. I want to see a heat-map of the number of reads across the four
plates, like a landscape. I expect to see the *valleys* caused by the combinations of
indices that were not assigned to any read.

```{r heatmap}
ggplot(data = Features,
       mapping = aes(x = i7, y = i5, fill = numReads)) +
   geom_tile() + geom_hline(yintercept = 8.5) + geom_vline(xintercept = 12.5) +
   scale_fill_gradient(trans = 'log',
                       breaks = c(1,10,100,1000,10000,100000,1000000,10000000)) +
   theme(axis.text.x = element_text(angle = 90)) +
   scale_y_discrete(limits = rev) +
   annotate(geom = 'text', x = c(6,18,6,18), y=c(12,12,4,4), label=c('A','B','C','D'))
```

## On the amount of index hopping
There are 104 combinations of indices that do not correspond to any real
sample, and received between 0 and `r max(Features[! Features$isReal, 'numReads'])`
reads. We need to model the process of index hopping to account for it. An initial
hypothesis we can test is if the number of reads sequenced with the same i5 or i7
index is directly related to the amount of index hopping into a particular combination.
Initial observation of the heatmap above suggests that is the case. Let's see.

```{r hopping}
# I build a data frame for mock samples, with number of reads with the same
# index among all real samples or among those in the same plate
Hopping <- data.frame(numReads = Features[! Features$isReal, 'numReads'],
                      plate = Features[! Features$isReal, 'plate'],
                      row.names = rownames(Features)[! Features$isReal])
Hopping$i5real  <- sapply(rownames(Hopping), function(x) {
   sum(Features[Features$i5 == Features[x, 'i5'] & Features$isReal, 'numReads'])})
Hopping$i5plate <- sapply(rownames(Hopping), function(x) {
   sum(Features[Features$i5 == Features[x, 'i5'] &
                Features$plate == Features[x,'plate'] &
                Features$isReal, 'numReads'])})
Hopping$i7real  <- sapply(rownames(Hopping), function(x) {
   sum(Features[Features$i7 == Features[x, 'i7'] & Features$isReal, 'numReads'])})
Hopping$i7plate <- sapply(rownames(Hopping), function(x) {
   sum(Features[Features$i7 == Features[x, 'i7'] &
                Features$plate == Features[x, 'plate'] &
                Features$isReal, 'numReads'])})
summary(lm(numReads ~ i5real + i7real, data = Hopping))

ggplot(data = Hopping, mapping = aes(x = i5real, y = numReads, color = plate)) +
   geom_point() + xlab('Number of reads from samples with same i5') +
   ylab('Number of misassigned reads')

ggplot(data = Hopping, mapping = aes(x = i7real, y = numReads, color = i5real)) +
   geom_point() + xlab('Number of reads from samples with same i7') +
   ylab('Number of misassigned reads')
```


## SessionInfo

```{r sessioninfo}
sessionInfo()
```